Description: Fixes to allow midgard r16p0 to build against 4.14 headers
Author: Guillaume Tucker <guillaume.tucker@collabora.com>
Forwarded: no
Reviewed-By: Wookey <wookey@debian.org>
Last-Update: 2018-01-15

--- mali-midgard-16.0.orig/mali-midgard-16.0/mali_kbase_jd.c
+++ mali-midgard-16.0/mali-midgard-16.0/mali_kbase_jd.c
@@ -975,7 +975,7 @@ bool jd_submit_atom(struct kbase_context
 	 * the scheduler: 'not ready to run' and 'dependency-only' jobs. */
 	jctx->job_nr++;
 
-	katom->start_timestamp.tv64 = 0;
+	katom->start_timestamp = 0;
 	katom->udata = user_atom->udata;
 	katom->kctx = kctx;
 	katom->nr_extres = user_atom->nr_extres;
--- mali-midgard-16.0.orig/mali-midgard-16.0/mali_kbase_mem.c
+++ mali-midgard-16.0/mali-midgard-16.0/mali_kbase_mem.c
@@ -31,6 +31,7 @@
 #include <linux/bug.h>
 #include <linux/compat.h>
 #include <linux/version.h>
+#include <linux/sched/mm.h>
 
 #include <mali_kbase_config.h>
 #include <mali_kbase.h>
@@ -2159,7 +2160,7 @@ static int kbase_jd_user_buf_map(struct
 			address,
 			alloc->imported.user_buf.nr_pages,
 			reg->flags & KBASE_REG_GPU_WR ? FOLL_WRITE : 0,
-			pages, NULL);
+			pages, NULL, NULL);
 #endif
 
 	if (pinned_pages <= 0)
--- mali-midgard-16.0.orig/mali-midgard-16.0/mali_kbase_mem_linux.c
+++ mali-midgard-16.0/mali-midgard-16.0/mali_kbase_mem_linux.c
@@ -1711,9 +1711,9 @@ static void kbase_cpu_vm_close(struct vm
 KBASE_EXPORT_TEST_API(kbase_cpu_vm_close);
 
 
-static int kbase_cpu_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+static int kbase_cpu_vm_fault(struct vm_fault *vmf)
 {
-	struct kbase_cpu_mapping *map = vma->vm_private_data;
+	struct kbase_cpu_mapping *map = vmf->vma->vm_private_data;
 	pgoff_t rel_pgoff;
 	size_t i;
 	pgoff_t addr;
@@ -1735,9 +1735,10 @@ static int kbase_cpu_vm_fault(struct vm_
 
 	/* insert all valid pages from the fault location */
 	i = rel_pgoff;
-	addr = (pgoff_t)((uintptr_t)vmf->virtual_address >> PAGE_SHIFT);
-	while (i < map->alloc->nents && (addr < vma->vm_end >> PAGE_SHIFT)) {
-		int ret = vm_insert_pfn(vma, addr << PAGE_SHIFT,
+	addr = (pgoff_t)((uintptr_t)vmf->address >> PAGE_SHIFT);
+	while (i < map->alloc->nents &&
+	       (addr < vmf->vma->vm_end >> PAGE_SHIFT)) {
+		int ret = vm_insert_pfn(vmf->vma, addr << PAGE_SHIFT,
 		    PFN_DOWN(map->alloc->pages[i]));
 		if (ret < 0 && ret != -EBUSY)
 			goto locked_bad_fault;
@@ -2619,4 +2620,3 @@ void kbase_va_free(struct kbase_context
 #endif
 }
 KBASE_EXPORT_SYMBOL(kbase_va_free);
-
